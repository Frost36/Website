(* ASCII Art
 * Matthew McKay (mjmckay)
 * April 7, 2011
 * This is a program that calculates an approximation of the Mandelbrot set and
 * uses that to display an ASCII rendering of the set given a specific range (which
 * can be easily changed with the three variables above the whatisart function).
 * I also hard-coded a penguin, in case you wanted to see that
 * (I commented it out so it wouldn't show up when the file was used)
 *)

Control.Print.printLength := 100;
Control.Print.printDepth := 100;

datatype ascii = A of ascii list | L of string

(*These constants are merely defined to provide a good layout of the ascii type once displayed*)
val width = 64
val height = 32

(* Purpose: Creates a string of length width (as defined above) from the list of given strings
 * 			such that each string in the second list appears at the character number indicated
 * 			by the first list. The rest of the string is filled in with blank space.
 * Examples: 
 * createLine [0] ["Penguin!"] => "Penguin!                                                            "
 * createLine [5,9] ["a","b"] => "     a   b                                                          "
 *)
fun reccreateLine (pos:int list) (strs:string list) (n:int)=
    case pos of
      [] => " " ^ (case n=width of
               true => ""
             | false => reccreateLine pos strs (n+1))
    | x::xs => (case x=n of
                 true => (case strs of
                            [] => " " ^ reccreateLine xs strs (n+1)
                          | s::ss => s ^ reccreateLine xs ss (n+(String.size s)))
               | false => " " ^ reccreateLine pos strs (n+1))

(* Purpose: This is a wrapper function for the above function, which gets a line and
			turns it into a variable of type ascii
 *)
fun createLine pos chars  = L (reccreateLine pos chars 0)

type complex = real * real (*a+bi*)

val zero:complex = (0.0, 0.0)

infixr 3 ++
infixr 4 **

(* Purpose: Calculates the magnitude of a complex number *)
fun mag ((a,b):complex) =
	Math.sqrt (a*a+b*b)

(* Purpose: Calculates the sum of two complex numbers *)
fun ((a1,b1):complex) ++ ((a2,b2):complex) = 
	(a1+a2,b1+b2)

(* Purpose: Calculates the product of two complex numbers *)
fun ((a1,b1):complex) ** ((a2,b2):complex) = 
	(a1*a2-b1*b2,a1*b2+a2*b1)

(* Purpose: Calculates the next iteration of a complex number in the sequence
 *			for seeing if it is a Mandelbrot number *)
fun brot c k =
		c ** c ++ k
		
(* Purpose: Recursively calculates the next term in the sequence and checks if it gets too big
 *			to be in the Mandelbrot set (otherwise it ends after 10000 iterations assuming it
 *			is in the set) *)
fun recisMandelbrot (c:complex) (k:complex) (n:int) =
	let val c' = brot c k
	in case n > 10000 of
		true => true
	  | false => (case Real.>=((mag c'), 2.0) of
					true => false
				  | false => recisMandelbrot c' k (n+1))
	end

(* Purpose: A wrapper function for recisMandelbrot *)
fun isMandelbrot(c:complex) = recisMandelbrot zero c 0

(* Purpose: Determines approximately what the terms in the sequence approach *)
fun getMandelbrot (c:complex) (k:complex) (n:int) =
	let val c' = brot c k
	in (case n > 10000 of
			true => mag c'
		  | false => getMandelbrot c' k (n+1))
	end

(* Purpose: Converts a complex number into a character to be used for ASCII display *)
fun getChar (c:complex):char = 
	let val mc = getMandelbrot zero c 0
	in	Char.chr (Real.floor (35.0 + 89.0 * (mc / 2.0)))
	end

(* Purpose: Generates the lists that can be used to produce a single row ascii type to be displayed.
 *			It takes the complex number to start at and the distance to iterate through,
 * 			moving a constant distance each time for a total of width units *)
fun recgenerateRowLists (c:complex) (pos:int) (d:real) =
	case pos >= width of
		true => ([],[])
	  | false => 	let val (l1,l2) = recgenerateRowLists (c++(d / (Real.fromInt width), 0.0)) (pos+1) d
					in	case isMandelbrot c of
							false => (l1,l2)
						  | true => (pos::l1,(Char.toString (getChar c))::l2)
					end

(* Purpose: A wrapper function for recgenerateRowLists *)
fun generateRowLists (c:complex) (d:real) = recgenerateRowLists c 0 d

(* Purpose: Takes the lists generated by  each row from generateRowLists and creates
 * 			an ascii representation for each one of them and puts them into a list*)
fun recgenerateRows (c:complex) (pos:int) (xdist:real) (ydist:real) =
	case pos >= height of
		true => []
	  | false => 	let val l = recgenerateRows (c++(0.0,~ydist / (Real.fromInt height))) (pos+1) xdist ydist
						val (l1,l2) = generateRowLists c xdist
						val s = createLine l1 l2
					in	s :: l
					end
					
(* Purpose: A wrapper function for recgenerateRows *)
fun generateRows (c:complex) (x:real) (y:real) = recgenerateRows c 0 x y

(* Purpose: Creates an ascii type that can be displayed (preferably with the terminal
 * 			at width about 80, but no less) *)
fun createASCII (c:complex) (x:real) (y:real) = A (generateRows c x y)
	
val corner = (~2.4,1.0) (*Upper left hand corner of section that you want to draw*)
val xdistance = 3.0		(*Amount of the graph you want to display to the right of corner*)
val ydistance = 2.0		(*Amount of the graph you want to display below corner*)
	
fun whatisart () = createASCII corner xdistance ydistance